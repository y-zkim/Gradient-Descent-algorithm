# -*- coding: utf-8 -*-
"""TD2_IA_Avancée.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yTJ7uNLAMPYYoDU2yFlvynCsixIio_m0

# A. Descente du gradient

##  1. La régression linéaire univariée ou monodimensionnelle

### a. Affichage des couples (x,y)
"""

import pandas as pd

# Creation of dataset 
data_table = {'x':[5,7,6,5,8,3,9,4,4,7], 'y':[0.3,0.6,0.45,0.34,0.78,0.2,0.75,0.36,0.28,0.62]}

# Assinging data to dataframe

df = pd.DataFrame(data_table)
df

"""### b. Algorithme de la descente du gradient"""

#import matplotlib.pyplot as plt
#X =  df.iloc[0:len(df),0]
#Y =  df.iloc[0:len(df),1]
#M = len(X)
# Implementation of gradient descent in linear regression
import numpy as np
import matplotlib.pyplot as plt

# Fonction de coût
def error(m, b, X, Y):
    return sum(((m * x + b) - Y[idx])**2 for idx, x in enumerate(X)) / float(len(X))

# Gradient du paramètre m
def m_grad(m, b, X, Y):
    return sum(-2 * x * (Y[idx] - (m * x + b)) for idx, x in enumerate(X)) / float(len(X))

# Gradient du paramètre b
def b_grad(m, b, X, Y):
    return sum(-2 * (Y[idx] - (m * x + b)) for idx, x in enumerate(X)) / float(len(X))

def gradient_descent_LR(X, Y, epochs, lr):
    assert(len(X) == len(Y))
    m = 0
    b = 0
    for e in range(epochs):
        m = m - lr * m_grad(m, b, X, Y)
        b = b - lr * b_grad(m, b, X, Y)
    return m, b

if __name__ == '__main__':
    # Génération du jeu de données
    X = df['x']
    Y = df['y']

    # Exécution de l'algorithme
    m, b = gradient_descent_LR(X, Y, epochs=10000, lr=0.001)

    # Visualisation de la droite avec les valeurs de m et b trouvées par descente de gradient
    line_x = [min(X), max(X)]
    line_y = [(m * i) + b for i in line_x]
    plt.plot(line_x, line_y, 'b')
    plt.plot(X, Y, 'ro')
    plt.show()

# Même solution
w0=0
w1=0
L=0.001
epochs=1000
n=float(len(X))
for i in range(epochs):
  Y_pred=w0*X+w1
  D_w0=(-2/n)*sum(X*(Y-Y_pred))
  D_w1=(-2/n)*sum(Y-Y_pred)
  w0=w0-L*D_w0
  w1=w1-L*D_w1
  
print(w0,w1)
plt.scatter(X,Y)
plt.plot([min(X),max(X)], [min(Y_pred),max(Y_pred)], color='red')
plt.show()

